# Stfor _gdb (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Tuple, List, Optional, Dict, Iterator, Callable
from typing import Union, Iterable, Sequence, NewType
from typing import TypeVar, Generic

Buffer = Any

frame_type = NewType('frame_type', int)
bptype_type = NewType('bptype_type', int)

ARCH_FRAME: frame_type
BP_ACCESS_WATCHPOINT: bptype_type
BP_BREAKPOINT: bptype_type
BP_HARDWARE_WATCHPOINT: bptype_type
BP_NONE: bptype_type
BP_READ_WATCHPOINT: bptype_type
BP_WATCHPOINT: bptype_type

command_class_enum = NewType('command_class_enum', int)
COMMAND_BREAKPOINTS: command_class_enum
COMMAND_DATA: command_class_enum
COMMAND_FILES: command_class_enum
COMMAND_MAINTENANCE: command_class_enum
COMMAND_NONE: command_class_enum
COMMAND_OBSCURE: command_class_enum
COMMAND_RUNNING: command_class_enum
COMMAND_STACK: command_class_enum
COMMAND_STATUS: command_class_enum
COMMAND_SUPPORT: command_class_enum
COMMAND_TRACEPOINTS: command_class_enum
COMMAND_USER: command_class_enum

command_completer_type = NewType('command_completer_type', int)
COMPLETE_COMMAND: command_completer_type
COMPLETE_EXPRESSION: command_completer_type
COMPLETE_FILENAME: command_completer_type
COMPLETE_LOCATION: command_completer_type
COMPLETE_NONE: command_completer_type
COMPLETE_SYMBOL: command_completer_type


DUMMY_FRAME: frame_type

unwind_stop_reason = NewType('unwind_stop_reason', int)
FRAME_UNWIND_INNER_ID: unwind_stop_reason
FRAME_UNWIND_MEMORY_ERROR: unwind_stop_reason
FRAME_UNWIND_NO_REASON: unwind_stop_reason
FRAME_UNWIND_NO_SAVED_PC: unwind_stop_reason
FRAME_UNWIND_NULL_ID: unwind_stop_reason
FRAME_UNWIND_OUTERMOST: unwind_stop_reason
FRAME_UNWIND_SAME_ID: unwind_stop_reason
FRAME_UNWIND_UNAVAILABLE: unwind_stop_reason
HOST_CONFIG: str
INLINE_FRAME: frame_type

minimal_symbol_type = NewType('minimal_symbol_type', int)
MINSYMBOL_TYPE_ABS: minimal_symbol_type
MINSYMBOL_TYPE_BSS: minimal_symbol_type
MINSYMBOL_TYPE_DATA: minimal_symbol_type
MINSYMBOL_TYPE_FILE_BSS: minimal_symbol_type
MINSYMBOL_TYPE_FILE_DATA: minimal_symbol_type
MINSYMBOL_TYPE_FILE_TEXT: minimal_symbol_type
MINSYMBOL_TYPE_SLOT_GOT_PLT: minimal_symbol_type
MINSYMBOL_TYPE_SOLIB_TRAMPOLINE: minimal_symbol_type
MINSYMBOL_TYPE_TEXT: minimal_symbol_type
MINSYMBOL_TYPE_TEXT_GNU_IFUNC: minimal_symbol_type
MINSYMBOL_TYPE_UNKNOWN: minimal_symbol_type

NORMAL_FRAME: frame_type

var_types_enum = NewType('var_types_enum', int)
PARAM_AUTO_BOOLEAN: var_types_enum
PARAM_BOOLEAN: var_types_enum
PARAM_ENUM: var_types_enum
PARAM_FILENAME: var_types_enum
PARAM_INTEGER: var_types_enum
PARAM_OPTIONAL_FILENAME: var_types_enum
PARAM_STRING: var_types_enum
PARAM_STRING_NOESCAPE: var_types_enum
PARAM_UINTEGER: var_types_enum
PARAM_ZINTEGER: var_types_enum
PARAM_ZUINTEGER: var_types_enum
PARAM_ZUINTEGER_UNLIMITED: var_types_enum
SENTINEL_FRAME: frame_type
SIGTRAMP_FRAME: frame_type

stream_type = NewType('stream_type', int)
STDERR: stream_type
STDLOG: stream_type
STDOUT: stream_type

domain_enum_type = NewType('domain_enum_type', int)
address_class_type = NewType('address_class_type', int)
SYMBOL_COMMON_BLOCK_DOMAIN: domain_enum_type
SYMBOL_FUNCTIONS_DOMAIN: domain_enum_type
SYMBOL_LOC_ARG: address_class_type
SYMBOL_LOC_BLOCK: address_class_type
SYMBOL_LOC_COMMON_BLOCK: address_class_type
SYMBOL_LOC_COMPUTED: address_class_type
SYMBOL_LOC_CONST: address_class_type
SYMBOL_LOC_CONST_BYTES: address_class_type
SYMBOL_LOC_LABEL: address_class_type
SYMBOL_LOC_LOCAL: address_class_type
SYMBOL_LOC_OPTIMIZED_OUT: address_class_type
SYMBOL_LOC_REF_ARG: address_class_type
SYMBOL_LOC_REGISTER: address_class_type
SYMBOL_LOC_REGPARM_ADDR: address_class_type
SYMBOL_LOC_STATIC: address_class_type
SYMBOL_LOC_TYPEDEF: address_class_type
SYMBOL_LOC_UNDEF: address_class_type
SYMBOL_LOC_UNRESOLVED: address_class_type
SYMBOL_MODULE_DOMAIN: domain_enum_type
SYMBOL_STRUCT_DOMAIN: domain_enum_type
SYMBOL_TYPES_DOMAIN: domain_enum_type
SYMBOL_UNDEF_DOMAIN: domain_enum_type
SYMBOL_VARIABLES_DOMAIN: domain_enum_type
SYMBOL_VAR_DOMAIN: domain_enum_type
TAILCALL_FRAME: frame_type
TARGET_CONFIG: str

type_code_enum = NewType('type_code_enum', int)
TYPE_CODE_ARRAY: type_code_enum
TYPE_CODE_BITSTRING: type_code_enum
TYPE_CODE_BOOL: type_code_enum
TYPE_CODE_CHAR: type_code_enum
TYPE_CODE_COMPLEX: type_code_enum
TYPE_CODE_DECFLOAT: type_code_enum
TYPE_CODE_ENUM: type_code_enum
TYPE_CODE_ERROR: type_code_enum
TYPE_CODE_FLAGS: type_code_enum
TYPE_CODE_FLT: type_code_enum
TYPE_CODE_FUNC: type_code_enum
TYPE_CODE_INT: type_code_enum
TYPE_CODE_INTERNAL_FUNCTION: type_code_enum
TYPE_CODE_MEMBERPTR: type_code_enum
TYPE_CODE_METHOD: type_code_enum
TYPE_CODE_METHODPTR: type_code_enum
TYPE_CODE_NAMESPACE: type_code_enum
TYPE_CODE_PTR: type_code_enum
TYPE_CODE_RANGE: type_code_enum
TYPE_CODE_REF: type_code_enum
TYPE_CODE_RVALUE_REF: type_code_enum
TYPE_CODE_SET: type_code_enum
TYPE_CODE_STRING: type_code_enum
TYPE_CODE_STRUCT: type_code_enum
TYPE_CODE_TYPEDEF: type_code_enum
TYPE_CODE_UNION: type_code_enum
TYPE_CODE_VOID: type_code_enum
VERSION: str

hw_bp_type = NewType('hw_bp_type', int)
WP_ACCESS: hw_bp_type
WP_READ: hw_bp_type
WP_WRITE: hw_bp_type

def breakpoints() -> Tuple[Breakpoint, ...]: ...
def cli() -> None: ...
def convenience_variable(name: str) -> Value: ...
def current_objfile() -> Optional[Objfile]: ...
def current_recording() -> Optional[Record]: ...
def current_target() -> Optional[Target]: ...
def decode_line(loc: str) -> Tuple[str, Optional[Tuple[Symtab_and_line, ...]]]: ...
def default_visualizer(value: Value) -> Any: ...
def execute(command: str, *args: bool, **kwargs: bool) -> Optional[str]: ...
def flush(stream: Optional[int] = ...) -> None: ...
def frame_stop_reason_string(reason: unwind_stop_reason) -> str: ...
def history(i: int) -> Value: ...
def inferiors() -> List[Inferior]: ...
def invalidate_cached_frames() -> None: ...
def lookup_global_symbol(name: str, domain: Optional[int] = ...) -> Optional[Symbol]: ...
def lookup_minimal_symbol(name: str, sfile: Optional[str] = ..., objfile: Optional[Objfile] = ...) -> Optional[MinSymbol]: ...
def lookup_objfile(name: str, by_build_id: Optional[bool] = ...) -> Objfile: ...
def lookup_symbol(name: str, block: Optional[Block] = ..., domain: Optional[int] = ...) -> Tuple[Optional[Symbol], bool]: ...
def lookup_type(name: str, block: Optional[Block] = ...) -> Type: ...
def newest_frame() -> Frame: ...
def parameter(var: str) -> Any: ...
def parse_and_eval(str: str) -> Value: ...
def post_event(event: Callable[[None], Any]) -> None: ...
def progspaces() -> List[Progspace]: ...
def rbreak(regex: str, **kwargs: Union[bool, int, Iterable[Symtab]]) -> List[Breakpoint]: ...
def selected_frame() -> Frame: ...
def selected_inferior() -> Inferior: ...
def selected_thread() -> InferiorThread: ...
def set_convenience_variable(name: str, value: Value) -> None: ...
def start_recording(method: Optional[str] = ..., format: Optional[str] = ...) -> Record: ...
def stop_recording() -> None: ...
def string_to_argv(string: str) -> List[str]: ...
def target_charset() -> str: ...
def target_wide_charset() -> str: ...
def write(text: str, stream: Optional[int] = ...) -> None: ...

class Architecture:
    def disassemble(self, start_pc: int, end_pc: Optional[int] = ..., count: Optional[int] = ...) -> List[Dict[str, int]]: ...
    def name(self) -> str: ...

class Block:
    end: int = ...
    function: Optional[Symbol] = ...
    global_block: Block = ...
    is_global: bool = ...
    is_static: bool = ...
    start: int = ...
    static_block: Optional[Block] = ...
    superblock: Optional[Block] = ...
    symbols: Iterator[Symbol] = ...
    def is_valid(self) -> bool: ...
    def __iter__(self) -> BlockIterator: ...

class BlockIterator:
    def is_valid(self) -> bool: ...
    def __iter__(self) -> BlockIterator: ...
    def __next__(self) -> Symbol: ...

class Breakpoint:
    commands: Optional[str] = ...
    condition: Optional[str] = ...
    enabled: bool = ...
    expression: Optional[str] = ...
    hit_count: int = ...
    ignore_count: int = ...
    location: Optional[str] = ...
    number: int = ...
    pending: bool = ...
    silent: bool = ...
    task: Optional[int] = ...
    temporary: bool = ...
    thread: Optional[int] = ...
    type: bptype_type = ...
    visible: bool = ...
    def __init__(self, *args: str, **kwargs: Union[str, bptype_type, hw_bp_type, bool, int]) -> None: ...
    def delete(self) -> None: ...
    def is_valid(self) -> bool: ...
    def __delattr__(self, name: str) -> Any: ...
    def __setattr__(self, name: str, value: Any) -> Any: ...

class BreakpointEvent(StopEvent): ...

class ClearObjFilesEvent(Event): ...

class Command:
    def __init__(self, name: str, command_class: command_class_enum,
                 completer_class: Optional[command_completer_type] = ...,
                 prefix: Optional[bool] = ...) -> None: ...
    def dont_repeat(self) -> None: ...

class ContinueEvent(ThreadEvent): ...

class Event: ...

EventType = TypeVar('EventType')

class EventRegistry(Generic[EventType]):
    def connect(self, func: Callable[[EventType], Any]) -> None: ...
    def disconnect(self, func: Callable[[EventType], Any]) -> None: ...

class ExitedEvent(Event): ...

class Field: ...

class FinishBreakpoint(Breakpoint):
    return_value: Optional[Value] = ...
    def __init__(self, frame: Optional[Frame] = ...,
                 internal: Optional[bool] = ...) -> None: ...

class Frame:
    def architecture(self) -> Architecture: ...
    def block(self) -> Block: ...
    def find_sal(self) -> Symtab_and_line: ...
    def function(self) -> Symbol: ...
    def is_valid(self) -> bool: ...
    def name(self) -> str: ...
    def newer(self) -> Frame: ...
    def older(self) -> Frame: ...
    def pc(self) -> int: ...
    def read_register(self, register_name: str) -> Value: ...
    def read_var(self, var: Symbol, block: Optional[Block] = ...) -> Value: ...
    def select(self) -> None: ...
    def type(self) -> int: ...
    def unwind_stop_reason(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

class Function:
    def __init__(self, name: str) -> None: ...

class GdbError(Exception): ...

IntValue = Union[Value, int]

class Inferior:
    executing: bool = ...
    num: int = ...
    pid: bool = ...
    progspace: Progspace = ...
    was_attached: bool = ...
    def appeared(self, pid: int) -> None: ...
    def architecture(self) -> Architecture: ...
    def delete_thread(self, ptid: Tuple[int, int, int]) -> None: ...
    def is_valid(self) -> bool: ...
    def new_thread(self, ptid: Tuple[int, int, int],
                   priv: Optional[Any] = ...) -> InferiorThread: ...
    def read_memory(self, address: IntValue, length: IntValue) -> Membuf: ...
    def search_memory(self, address: IntValue, length: IntValue,
                      pattern: Buffer) -> int: ...
    def thread_from_handle(self, handle: Buffer) -> InferiorThread: ...
    def thread_from_thread_handle(self, handle: Buffer) -> InferiorThread: ...
    def threads(self) -> List[InferiorThread]: ...
    def write_memory(self, address: IntValue, buffer: Buffer,
                     length: Optional[int] = ...) -> None: ...

class InferiorCallPostEvent(Event): ...

class InferiorCallPreEvent(Event): ...

class InferiorDeletedEvent(Event): ...

class InferiorThread:
    executing: bool = ...
    global_num: int = ...
    inferior: Inferior = ...
    info: Any = ...
    name: str = ...
    num: int = ...
    ptid: Tuple[int, int, int] = ...
    registers: Dict[str, Register] = ...
    def handle(self) -> bytes: ...
    def is_exited(self) -> bool: ...
    def is_running(self) -> bool: ...
    def is_stopped(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def switch(self) -> None: ...

class LineTable:
    def has_line(self, lineno: int) -> bool: ...
    def is_valid(self) -> bool: ...
    def line(self, lineno: int) -> Tuple[LineTableEntry, ...] : ...
    def source_lines(self) -> List: ...
    def __iter__(self) -> LineTableIterator: ...

class LineTableEntry:
    line: int = ...
    pc: int = ...

class LineTableIterator:
    def is_valid(self) -> bool: ...
    def __iter__(self) -> LineTableIterator: ...
    def __next__(self) -> LineTableEntry: ...

class Membuf:
    def tobytes(self) -> bytes: ...


class MemoryChangedEvent(Event): ...

class MemoryError(error): ...

class MinSymbol:
    filename: str = ...
    linkage_name: str = ...
    name: str = ...
    print_name: str = ...
    section: Optional[str] = ...
    type: minimal_symbol_type = ...
    def is_code(self) -> bool: ...
    def is_data(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def value(self) -> Value: ...

class NewInferiorEvent(Event): ...

class NewObjFileEvent(Event): ...

class NewThreadEvent(ThreadEvent): ...

class NotAvailableError(error): ...

class Objfile:
    architecture: Architecture = ...
    build_id: Optional[str] = ...
    filename: Optional[str] = ...
    frame_filters: Dict[Any, Any] = ...
    frame_unwinders: List[Any] = ...
    owner: Optional[Objfile] = ...
    pretty_printers: List[Any] = ...
    progspace: Progspace = ...
    type_printers: List[Any] = ...
    username: Optional[str] = ...
    xmethods: List[Any] = ...
    def add_separate_debug_file(self, file_name: str) -> None: ...
    def has_symbols(self) -> bool: ...
    def is_valid(self) -> bool: ...

class Parameter:
    def __init__(self, name: str, cmdtype: int, parmclass: int,
                 enum_values: Optional[Sequence[str]] = ...) -> None: ...
    def __delattr__(self, name: str) -> None: ...
    def __setattr__(self, name: str, value: Any) -> None: ...

class PendingFrame:
    def create_unwind_info(self, frame_id: Any) -> UnwindInfo: ...
    def read_register(self, register_id: Union[str, int]) -> Value: ...


class Progspace:
    filename: Optional[str] = ...
    frame_filters: Dict[Any, Any] = ...
    frame_unwinders: List[Any] = ...
    pretty_printers: List[Any] = ...
    type_printers: List[Any] = ...
    xmethods: List[Any] = ...
    def __init__(self) -> None: ...
    def block_for_pc(self, pc: int) -> Optional[Block]: ...
    def find_pc_line(self, pc: int) -> Symtab_and_line: ...
    def is_valid(self) -> bool: ...
    def objfiles(self) -> List[Objfile]: ...
    def solib_name(self, name: int) -> Optional[str]: ...

class Register:
    name: Optional[str] = ...
    regnum: int = ...
    size: int = ...
    type: Type = ...
    value: Union[Value, int] = ...

class RegisterChangedEvent(Event): ...

class SignalEvent(StopEvent): ...

class StopEvent(ThreadEvent): ...

class Symbol:
    addr_class: int = ...
    is_argument: bool = ...
    is_constant: bool = ...
    is_function: bool = ...
    is_variable: bool = ...
    line: int = ...
    linkage_name: str = ...
    name: str = ...
    needs_frame: bool = ...
    print_name: str = ...
    section: Optional[str] = ...
    symtab: Symtab = ...
    type: Type = ...
    def is_valid(self) -> bool: ...
    def value(self, frame: Optional[Frame] = ...) -> Value: ...

class Symtab:
    filename: str = ...
    objfile: Objfile = ...
    producer: Optional[str] = ...
    def fullname(self) -> str: ...
    def global_block(self) -> Block: ...
    def is_valid(self) -> bool: ...
    def linetable(self) -> LineTable: ...
    def static_block(self) -> Block: ...

class Symtab_and_line:
    last: Optional[int] = ...
    line: int = ...
    pc: int = ...
    symtab: Symtab = ...
    def is_valid(self) -> bool: ...

class Target:
    TARGET_OBJECT_AUXV: int = ...
    TARGET_OBJECT_AVAILABLE_FEATURES: int = ...
    TARGET_OBJECT_AVR: int = ...
    TARGET_OBJECT_BTRACE: int = ...
    TARGET_OBJECT_BTRACE_CONF: int = ...
    TARGET_OBJECT_CODE_MEMORY: int = ...
    TARGET_OBJECT_DARWIN_DYLD_INFO: int = ...
    TARGET_OBJECT_EXEC_FILE: int = ...
    TARGET_OBJECT_FDPIC: int = ...
    TARGET_OBJECT_FLASH: int = ...
    TARGET_OBJECT_FREEBSD_PS_STRINGS: int = ...
    TARGET_OBJECT_FREEBSD_VMMAP: int = ...
    TARGET_OBJECT_LIBRARIES: int = ...
    TARGET_OBJECT_LIBRARIES_AIX: int = ...
    TARGET_OBJECT_LIBRARIES_SVR4: int = ...
    TARGET_OBJECT_MEMORY: int = ...
    TARGET_OBJECT_MEMORY_MAP: int = ...
    TARGET_OBJECT_OPENVMS_UIB: int = ...
    TARGET_OBJECT_OSDATA: int = ...
    TARGET_OBJECT_RAW_MEMORY: int = ...
    TARGET_OBJECT_SIGNAL_INFO: int = ...
    TARGET_OBJECT_SPU: int = ...
    TARGET_OBJECT_STACK_MEMORY: int = ...
    TARGET_OBJECT_STATIC_TRACE_DATA: int = ...
    TARGET_OBJECT_THREADS: int = ...
    TARGET_OBJECT_TRACEFRAME_INFO: int = ...
    TARGET_OBJECT_UNWIND_TABLE: int = ...
    TARGET_OBJECT_WCOOKIE: int = ...
    arch: Architecture = ...
    docstring: str = ...
    longname: str = ...
    name: str = ...
    shortname: str = ...
    stratum: int = ...
    @classmethod
    def __init__(self) -> None: ...
    def register(self) -> Any: ...
    def unregister(self) -> Any: ...

    def stacked_target(self) -> bool: ...
    def open(self, argstring: str, from_tty: bool) -> None: ...
    def close(self) -> None: ...
    def info(self, thread: InferiorThread) -> str: ...
    def xfer_partial(self, object: int, annex: str, readbuf: bytearray,
                     writebuf: bytearray, offset: int, len: int) -> int: ...
    def extra_thread_info(self) -> str: ...
    def update_thread_list(self) -> None: ...
    def thread_alive(self, ptid: Tuple[int, int, int]) -> bool: ...
    def pid_to_str(self, ptid: Tuple[int, int,int]) -> str: ...
    def fetch_registers(self, thread: InferiorThread,
                        register: Register) -> None: ...
    def prepare_to_store(self, thread: InferiorThread) -> None: ...
    def store_registers(self, thread: InferiorThread,
                        register: Register) -> None: ...
    def has_execution(self, ptid: Tuple[int, int, int]) -> bool: ...

class TargetXferEOF(EOFError): ...

class TargetXferUnavailable(LookupError): ...

class ThreadEvent(Event): ...

class Type:
    alignof: int = ...
    code: int = ...
    name: Optional[str] = ...
    sizeof: int = ...
    tag: Optional[str] = ...
    def array(self, low: int, high: Optional[int] = ...) -> Type: ...
    def const(self) -> Type: ...
    def fields(self) -> List: ...
    def get(self, k: str,
            default: Optional[Field] = ...) -> Optional[Field]: ...
    def has_key(self, k: str) -> bool: ...
    def items(self) -> List: ...
    def iteritems(self) -> Iterator[Tuple[str, Field]]: ...
    def iterkeys(self) -> Iterator[str]: ...
    def itervalues(self) -> Iterator[Field]: ...
    def keys(self) -> List: ...
    def optimized_out(self) -> Value: ...
    def pointer(self) -> Type: ...
    def range(self) -> tuple: ...
    def reference(self) -> Type: ...
    def strip_typedefs(self) -> Type: ...
    def target(self) -> Type: ...
    def template_argument(self, arg: int, block: Optional[Block] = ...) -> Type: ...
    def unqualified(self) -> Type: ...
    def values(self) -> List: ...
    def vector(self, low: int, high: Optional[int] = ...) -> Type: ...
    def volatile(self) -> Type: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, k: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __gt__(self, other: Any) -> bool: ...
    def __iter__(self) -> TypeIterator: ...
    def __le__(self, other: Any) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

class TypeIterator:
    def __iter__(self) -> Any: ...
    def __next__(self) -> Any: ...

class UnwindInfo:
    def add_saved_register(self, reg: IntValue, value: Value) -> None: ...

class Value:
    address: Value = ...
    dynamic_type: Type = ...
    is_lazy: bool = ...
    is_optimized_out: bool = ...
    type: Type = ...
    @classmethod
    def __init__(self, val: Union[Value, Buffer],
                 type: Optional[Type]) -> None: ...
    def cast(self, type: Type) -> Value: ...
    def const_value(self) -> Value: ...
    def dereference(self) -> Value: ...
    def dynamic_cast(self, type: Type) -> Value: ...
    def fetch_lazy(self) -> None: ...
    def format_string(self, **kwargs: Union[bool, int, str]) -> str: ...
    def lazy_string(self, encoding: Optional[str] = ..., length: Optional[int] = ...) -> LazyString: ...
    def reference_value(self) -> Value: ...
    def referenced_value(self) -> Value: ...
    def reinterpret_cast(self, type: Type) -> Value: ...
    def rvalue_reference_value(self) -> Value: ...
    def string(self, encoding: Optional[str] = ..., errors: Optional[str] = ..., length: Optional[int] = ...) -> str: ...
    def __abs__(self) -> Value: ...
    def __add__(self, other: Any) -> Value: ...
    def __and__(self, other: Any) -> Value: ...
    def __bool__(self) -> bool: ...
    def __call__(self, args: Tuple[Any, ...], kwargs: Dict[str, Any]) -> Any: ...
    def __delitem__(self, index: Any) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __float__(self) -> float: ...
    def __ge__(self, other: Any) -> bool: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __gt__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> Value: ...
    def __le__(self, other: Any) -> bool: ...
    def __len__(self) -> int: ...
    def __lshift__(self, other: Any) -> Value: ...
    def __lt__(self, other: Any) -> Value: ...
    def __mod__(self, other: Any) -> Any: ...
    def __mul__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> bool: ...
    def __neg__(self) -> Value: ...
    def __or__(self, other: Any) -> Value: ...
    def __pos__(self) -> Any: ...
    def __pow__(self, other: Any) -> Value: ...
    def __radd__(self, other: Any) -> Any: ...
    def __rand__(self, other: Any) -> Any: ...
    def __rlshift__(self, other: Any) -> Any: ...
    def __rmod__(self, other: Any) -> Any: ...
    def __rmul__(self, other: Any) -> Any: ...
    def __ror__(self, other: Any) -> Any: ...
    def __rpow__(self, other: Any) -> Any: ...
    def __rrshift__(self, other: Any) -> Any: ...
    def __rshift__(self, other: Any) -> Any: ...
    def __rsub__(self, other: Any) -> Any: ...
    def __rtruediv__(self, other: Any) -> Any: ...
    def __rxor__(self, other: Any) -> Any: ...
    def __setitem__(self, index: Any, object: Any) -> Any: ...
    def __sub__(self, other: Any) -> Value: ...
    def __truediv__(self, other: Any) -> Value: ...
    def __xor__(self, other: Any) -> Value: ...

class error(RuntimeError): ...

RecordPosition = Optional[Union[RecordInstruction, RecordGap]]

class Record:
    method: str = ...
    format: str = ...
    replay_position: RecordPosition = ...
    instruction_history: Optional[List[RecordInstruction]] = ...
    function_call_history: Optional[List[RecordFunctionSegment]] = ...
    begin: RecordPosition = ...
    end: RecordPosition = ...
    def goto(self, instruction: Record) -> None: ...

class RecordInstruction:
    number: int = ...
    sal: Symtab_and_line = ...
    pc: int = ...
    data: Buffer = ...
    decoded: str = ...
    size: int = ...
    is_speculative: bool = ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class RecordFunctionSegment:
    number: int = ...
    level: int = ...
    symbol: Symbol = ...
    instructions: List[RecordInstruction] = ...
    up: Optional[RecordFunctionSegment] = ...
    prev: Optional[RecordFunctionSegment] = ...
    next: Optional[RecordFunctionSegment] = ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class RecordGap:
    number: int = ...
    reason_code: int = ...
    reason_string: str = ...

class LazyString:
    address: int = ...
    encoding: str = ...
    length: int = ...
    type: Type = ...
    def value(self) -> str: ...
