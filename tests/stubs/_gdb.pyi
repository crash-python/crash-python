# Stfor _gdb (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from kdumpfile import kdumpfile as kdumpfile_type

from typing import Any, Tuple, List, Optional, Dict, Iterator, Callable
from typing import Union, Iterable, Sequence, NewType
from typing import TypeVar, Generic

Buffer = Any

frame_type = NewType('frame_type', int)
bptype_type = NewType('bptype_type', int)

ARCH_FRAME: frame_type
BP_ACCESS_WATCHPOINT: bptype_type
BP_BREAKPOINT: bptype_type
BP_HARDWARE_WATCHPOINT: bptype_type
BP_NONE: bptype_type
BP_READ_WATCHPOINT: bptype_type
BP_WATCHPOINT: bptype_type

command_class_enum = NewType('command_class_enum', int)
COMMAND_BREAKPOINTS: command_class_enum
COMMAND_DATA: command_class_enum
COMMAND_FILES: command_class_enum
COMMAND_MAINTENANCE: command_class_enum
COMMAND_NONE: command_class_enum
COMMAND_OBSCURE: command_class_enum
COMMAND_RUNNING: command_class_enum
COMMAND_STACK: command_class_enum
COMMAND_STATUS: command_class_enum
COMMAND_SUPPORT: command_class_enum
COMMAND_TRACEPOINTS: command_class_enum
COMMAND_USER: command_class_enum

command_completer_type = NewType('command_completer_type', int)
COMPLETE_COMMAND: command_completer_type
COMPLETE_EXPRESSION: command_completer_type
COMPLETE_FILENAME: command_completer_type
COMPLETE_LOCATION: command_completer_type
COMPLETE_NONE: command_completer_type
COMPLETE_SYMBOL: command_completer_type


DUMMY_FRAME: frame_type

unwind_stop_reason = NewType('unwind_stop_reason', int)
FRAME_UNWIND_INNER_ID: unwind_stop_reason
FRAME_UNWIND_MEMORY_ERROR: unwind_stop_reason
FRAME_UNWIND_NO_REASON: unwind_stop_reason
FRAME_UNWIND_NO_SAVED_PC: unwind_stop_reason
FRAME_UNWIND_NULL_ID: unwind_stop_reason
FRAME_UNWIND_OUTERMOST: unwind_stop_reason
FRAME_UNWIND_SAME_ID: unwind_stop_reason
FRAME_UNWIND_UNAVAILABLE: unwind_stop_reason
HOST_CONFIG: str
INLINE_FRAME: frame_type

minimal_symbol_type = NewType('minimal_symbol_type', int)
MINSYMBOL_TYPE_ABS: minimal_symbol_type
MINSYMBOL_TYPE_BSS: minimal_symbol_type
MINSYMBOL_TYPE_DATA: minimal_symbol_type
MINSYMBOL_TYPE_FILE_BSS: minimal_symbol_type
MINSYMBOL_TYPE_FILE_DATA: minimal_symbol_type
MINSYMBOL_TYPE_FILE_TEXT: minimal_symbol_type
MINSYMBOL_TYPE_SLOT_GOT_PLT: minimal_symbol_type
MINSYMBOL_TYPE_SOLIB_TRAMPOLINE: minimal_symbol_type
MINSYMBOL_TYPE_TEXT: minimal_symbol_type
MINSYMBOL_TYPE_TEXT_GNU_IFUNC: minimal_symbol_type
MINSYMBOL_TYPE_UNKNOWN: minimal_symbol_type

NORMAL_FRAME: frame_type

var_types_enum = NewType('var_types_enum', int)
PARAM_AUTO_BOOLEAN: var_types_enum
PARAM_BOOLEAN: var_types_enum
PARAM_ENUM: var_types_enum
PARAM_FILENAME: var_types_enum
PARAM_INTEGER: var_types_enum
PARAM_OPTIONAL_FILENAME: var_types_enum
PARAM_STRING: var_types_enum
PARAM_STRING_NOESCAPE: var_types_enum
PARAM_UINTEGER: var_types_enum
PARAM_ZINTEGER: var_types_enum
PARAM_ZUINTEGER: var_types_enum
PARAM_ZUINTEGER_UNLIMITED: var_types_enum
SENTINEL_FRAME: frame_type
SIGTRAMP_FRAME: frame_type

stream_type = NewType('stream_type', int)
STDERR: stream_type
STDLOG: stream_type
STDOUT: stream_type

domain_enum_type = NewType('domain_enum_type', int)
address_class_type = NewType('address_class_type', int)
SYMBOL_COMMON_BLOCK_DOMAIN: domain_enum_type
SYMBOL_FUNCTIONS_DOMAIN: domain_enum_type
SYMBOL_LOC_ARG: address_class_type
SYMBOL_LOC_BLOCK: address_class_type
SYMBOL_LOC_COMMON_BLOCK: address_class_type
SYMBOL_LOC_COMPUTED: address_class_type
SYMBOL_LOC_CONST: address_class_type
SYMBOL_LOC_CONST_BYTES: address_class_type
SYMBOL_LOC_LABEL: address_class_type
SYMBOL_LOC_LOCAL: address_class_type
SYMBOL_LOC_OPTIMIZED_OUT: address_class_type
SYMBOL_LOC_REF_ARG: address_class_type
SYMBOL_LOC_REGISTER: address_class_type
SYMBOL_LOC_REGPARM_ADDR: address_class_type
SYMBOL_LOC_STATIC: address_class_type
SYMBOL_LOC_TYPEDEF: address_class_type
SYMBOL_LOC_UNDEF: address_class_type
SYMBOL_LOC_UNRESOLVED: address_class_type
SYMBOL_MODULE_DOMAIN: domain_enum_type
SYMBOL_STRUCT_DOMAIN: domain_enum_type
SYMBOL_TYPES_DOMAIN: domain_enum_type
SYMBOL_UNDEF_DOMAIN: domain_enum_type
SYMBOL_VARIABLES_DOMAIN: domain_enum_type
SYMBOL_VAR_DOMAIN: domain_enum_type
TAILCALL_FRAME: frame_type
TARGET_CONFIG: str

type_code_enum = NewType('type_code_enum', int)
TYPE_CODE_ARRAY: type_code_enum
TYPE_CODE_BITSTRING: type_code_enum
TYPE_CODE_BOOL: type_code_enum
TYPE_CODE_CHAR: type_code_enum
TYPE_CODE_COMPLEX: type_code_enum
TYPE_CODE_DECFLOAT: type_code_enum
TYPE_CODE_ENUM: type_code_enum
TYPE_CODE_ERROR: type_code_enum
TYPE_CODE_FLAGS: type_code_enum
TYPE_CODE_FLT: type_code_enum
TYPE_CODE_FUNC: type_code_enum
TYPE_CODE_INT: type_code_enum
TYPE_CODE_INTERNAL_FUNCTION: type_code_enum
TYPE_CODE_MEMBERPTR: type_code_enum
TYPE_CODE_METHOD: type_code_enum
TYPE_CODE_METHODPTR: type_code_enum
TYPE_CODE_NAMESPACE: type_code_enum
TYPE_CODE_PTR: type_code_enum
TYPE_CODE_RANGE: type_code_enum
TYPE_CODE_REF: type_code_enum
TYPE_CODE_RVALUE_REF: type_code_enum
TYPE_CODE_SET: type_code_enum
TYPE_CODE_STRING: type_code_enum
TYPE_CODE_STRUCT: type_code_enum
TYPE_CODE_TYPEDEF: type_code_enum
TYPE_CODE_UNION: type_code_enum
TYPE_CODE_VOID: type_code_enum
VERSION: str

hw_bp_type = NewType('hw_bp_type', int)
WP_ACCESS: hw_bp_type
WP_READ: hw_bp_type
WP_WRITE: hw_bp_type

def breakpoints() -> Tuple[Breakpoint, ...]: ...
def cli() -> None: ...
def convenience_variable(name: str) -> Value: ...
def current_objfile() -> Optional[Objfile]: ...
def current_recording() -> Optional[Record]: ...
def current_target() -> Optional[Target]: ...
def decode_line(loc: str) -> Tuple[str, Optional[Tuple[Symtab_and_line, ...]]]: ...
def default_visualizer(value: Value) -> Any: ...
def execute(command: str, *args: bool, **kwargs: bool) -> Optional[str]: ...
def flush(stream: Optional[int] = ...) -> None: ...
def frame_stop_reason_string(reason: unwind_stop_reason) -> str: ...
def history(i: int) -> Value: ...
def inferiors() -> List[Inferior]: ...
def invalidate_cached_frames() -> None: ...
def lookup_global_symbol(name: str, domain: Optional[int] = ...) -> Optional[Symbol]: ...
def lookup_minimal_symbol(name: str, sfile: Optional[str] = ..., objfile: Optional[Objfile] = ...) -> Optional[MinSymbol]: ...
def lookup_objfile(name: str, by_build_id: Optional[bool] = ...) -> Objfile: ...
def lookup_symbol(name: str, block: Optional[Block] = ..., domain: Optional[int] = ...) -> Tuple[Optional[Symbol], bool]: ...
def lookup_type(name: str, block: Optional[Block] = ...) -> Type: ...
def newest_frame() -> Frame: ...
def parameter(var: str) -> Any: ...
def parse_and_eval(str: str) -> Value: ...
def post_event(event: Callable[[None], Any]) -> None: ...
def progspaces() -> List[Progspace]: ...
def rbreak(regex: str, **kwargs: Union[bool, int, Iterable[Symtab]]) -> List[Breakpoint]: ...
def selected_frame() -> Frame: ...
def selected_inferior() -> Inferior: ...
def selected_thread() -> InferiorThread: ...
def set_convenience_variable(name: str, value: Value) -> None: ...
def start_recording(method: Optional[str] = ..., format: Optional[str] = ...) -> Record: ...
def stop_recording() -> None: ...
def string_to_argv(string: str) -> List[str]: ...
def target_charset() -> str: ...
def target_wide_charset() -> str: ...
def write(text: str, stream: Optional[int] = ...) -> None: ...

class Architecture:
    def disassemble(self, start_pc: int, end_pc: Optional[int] = ..., count: Optional[int] = ...) -> List[Dict[str, int]]: ...
    def name(self) -> str: ...

class Block:
    end: int = ...
    function: Optional[Symbol] = ...
    global_block: Block = ...
    is_global: bool = ...
    is_static: bool = ...
    start: int = ...
    static_block: Optional[Block] = ...
    superblock: Optional[Block] = ...
    symbols: Iterator[Symbol] = ...
    def is_valid(self) -> bool: ...
    def __iter__(self) -> BlockIterator: ...

class BlockIterator:
    def is_valid(self) -> bool: ...
    def __iter__(self) -> BlockIterator: ...
    def __next__(self) -> Symbol: ...

class Breakpoint:
    commands: Optional[str] = ...
    condition: Optional[str] = ...
    enabled: bool = ...
    expression: Optional[str] = ...
    hit_count: int = ...
    ignore_count: int = ...
    location: Optional[str] = ...
    number: int = ...
    pending: bool = ...
    silent: bool = ...
    task: Optional[int] = ...
    temporary: bool = ...
    thread: Optional[int] = ...
    type: bptype_type = ...
    visible: bool = ...
    def __init__(self, *args: str, **kwargs: Union[str, bptype_type, hw_bp_type, bool, int]) -> None: ...
    def delete(self) -> None: ...
    def is_valid(self) -> bool: ...
    def __delattr__(self, name: str) -> Any: ...
    def __setattr__(self, name: str, value: Any) -> Any: ...

class BreakpointEvent(StopEvent): ...

class ClearObjFilesEvent(Event): ...

class Command:
    def __init__(self, name: str, command_class: command_class_enum,
                 completer_class: Optional[command_completer_type] = ...,
                 prefix: Optional[bool] = ...) -> None: ...
    def dont_repeat(self) -> None: ...

class ContinueEvent(ThreadEvent): ...

class Event: ...

EventType = TypeVar('EventType')

class EventRegistry(Generic[EventType]):
    def connect(self, func: Callable[[EventType], Any]) -> None: ...
    def disconnect(self, func: Callable[[EventType], Any]) -> None: ...

class ExitedEvent(Event): ...

class Field:
    enumval: int = ...
    bitpos: int = ...

class FinishBreakpoint(Breakpoint):
    return_value: Optional[Value] = ...
    def __init__(self, frame: Optional[Frame] = ...,
                 internal: Optional[bool] = ...) -> None: ...

class Frame:
    def architecture(self) -> Architecture: ...
    def block(self) -> Block: ...
    def find_sal(self) -> Symtab_and_line: ...
    def function(self) -> Symbol: ...
    def is_valid(self) -> bool: ...
    def name(self) -> str: ...
    def newer(self) -> Frame: ...
    def older(self) -> Frame: ...
    def pc(self) -> int: ...
    def read_register(self, register_name: str) -> Value: ...
    def read_var(self, var: Symbol, block: Optional[Block] = ...) -> Value: ...
    def select(self) -> None: ...
    def type(self) -> int: ...
    def unwind_stop_reason(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

class Function:
    def __init__(self, name: str) -> None: ...

class GdbError(Exception): ...

IntValue = Union[Value, int]

class Inferior:
    num: int = ...
    pid: bool = ...
    progspace: Progspace = ...
    was_attached: bool = ...
    def appeared(self, pid: int) -> None: ...
    def architecture(self) -> Architecture: ...
    def is_valid(self) -> bool: ...
    def read_memory(self, address: IntValue, length: IntValue) -> Membuf: ...
    def search_memory(self, address: IntValue, length: IntValue,
                      pattern: Buffer) -> int: ...
    def thread_from_handle(self, handle: Buffer) -> InferiorThread: ...
    def thread_from_thread_handle(self, handle: Buffer) -> InferiorThread: ...
    def threads(self) -> List[InferiorThread]: ...
    def write_memory(self, address: IntValue, buffer: Buffer,
                     length: Optional[int] = ...) -> None: ...

class InferiorCallPostEvent(Event): ...

class InferiorCallPreEvent(Event): ...

class InferiorDeletedEvent(Event): ...

class InferiorThread:
    arch: Any = ...
    details: str = ...
    global_num: int = ...
    inferior: Inferior = ...
    info: Any = ...
    name: str = ...
    num: int = ...
    ptid: Tuple[int, int, int] = ...
    def handle(self) -> bytes: ...
    def is_exited(self) -> bool: ...
    def is_running(self) -> bool: ...
    def is_stopped(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def switch(self) -> None: ...

class LineTable:
    def has_line(self, lineno: int) -> bool: ...
    def is_valid(self) -> bool: ...
    def line(self, lineno: int) -> Tuple[LineTableEntry, ...] : ...
    def source_lines(self) -> List: ...
    def __iter__(self) -> LineTableIterator: ...

class LineTableEntry:
    line: int = ...
    pc: int = ...

class LineTableIterator:
    def is_valid(self) -> bool: ...
    def __iter__(self) -> LineTableIterator: ...
    def __next__(self) -> LineTableEntry: ...

class Membuf:
    def tobytes(self) -> bytes: ...


class MemoryChangedEvent(Event): ...

class MemoryError(error): ...

class MinSymbol:
    filename: str = ...
    linkage_name: str = ...
    name: str = ...
    print_name: str = ...
    section: Optional[str] = ...
    type: minimal_symbol_type = ...
    def is_code(self) -> bool: ...
    def is_data(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def value(self) -> Value: ...

class NewInferiorEvent(Event): ...

class NewObjFileEvent(Event): ...

class NewThreadEvent(ThreadEvent): ...

class NotAvailableError(error): ...

class Objfile:
    architecture: Architecture = ...
    build_id: Optional[str] = ...
    filename: Optional[str] = ...
    frame_filters: Dict[Any, Any] = ...
    frame_unwinders: List[Any] = ...
    owner: Optional[Objfile] = ...
    pretty_printers: List[Any] = ...
    progspace: Progspace = ...
    type_printers: List[Any] = ...
    username: Optional[str] = ...
    xmethods: List[Any] = ...
    def add_separate_debug_file(self, file_name: str) -> None: ...
    def has_symbols(self) -> bool: ...
    def is_valid(self) -> bool: ...

class Parameter:
    def __init__(self, name: str, cmdtype: int, parmclass: int,
                 enum_values: Optional[Sequence[str]] = ...) -> None: ...
    def __delattr__(self, name: str) -> None: ...
    def __setattr__(self, name: str, value: Any) -> None: ...

class PendingFrame:
    def create_unwind_info(self, frame_id: Any) -> UnwindInfo: ...
    def read_register(self, register_id: Union[str, int]) -> Value: ...


class Progspace:
    filename: Optional[str] = ...
    frame_filters: Dict[Any, Any] = ...
    frame_unwinders: List[Any] = ...
    pretty_printers: List[Any] = ...
    type_printers: List[Any] = ...
    xmethods: List[Any] = ...
    def __init__(self) -> None: ...
    def block_for_pc(self, pc: int) -> Optional[Block]: ...
    def find_pc_line(self, pc: int) -> Symtab_and_line: ...
    def is_valid(self) -> bool: ...
    def objfiles(self) -> List[Objfile]: ...
    def solib_name(self, name: int) -> Optional[str]: ...

class RegisterDescriptor:
    name: str = ...

RegisterNameType = Union[str, RegisterDescriptor]
RegisterValueType = Optional[Union[int, bytearray]]
RegisterCollectionType = Dict[RegisterNameType, RegisterValueType]

class RegisterChangedEvent(Event): ...

class SignalEvent(StopEvent): ...

class StopEvent(ThreadEvent): ...

class Symbol:
    addr_class: int = ...
    is_argument: bool = ...
    is_constant: bool = ...
    is_function: bool = ...
    is_variable: bool = ...
    line: int = ...
    linkage_name: str = ...
    name: str = ...
    needs_frame: bool = ...
    print_name: str = ...
    section: Optional[str] = ...
    symtab: Symtab = ...
    type: Type = ...
    def is_valid(self) -> bool: ...
    def value(self, frame: Optional[Frame] = ...) -> Value: ...

class Symtab:
    filename: str = ...
    objfile: Objfile = ...
    producer: Optional[str] = ...
    def fullname(self) -> str: ...
    def global_block(self) -> Block: ...
    def is_valid(self) -> bool: ...
    def linetable(self) -> LineTable: ...
    def static_block(self) -> Block: ...

class Symtab_and_line:
    last: Optional[int] = ...
    line: int = ...
    pc: int = ...
    symtab: Symtab = ...
    def is_valid(self) -> bool: ...

class Target:
    TARGET_OBJECT_AUXV: int = ...
    TARGET_OBJECT_AVAILABLE_FEATURES: int = ...
    TARGET_OBJECT_AVR: int = ...
    TARGET_OBJECT_BTRACE: int = ...
    TARGET_OBJECT_BTRACE_CONF: int = ...
    TARGET_OBJECT_CODE_MEMORY: int = ...
    TARGET_OBJECT_DARWIN_DYLD_INFO: int = ...
    TARGET_OBJECT_EXEC_FILE: int = ...
    TARGET_OBJECT_FDPIC: int = ...
    TARGET_OBJECT_FLASH: int = ...
    TARGET_OBJECT_FREEBSD_PS_STRINGS: int = ...
    TARGET_OBJECT_FREEBSD_VMMAP: int = ...
    TARGET_OBJECT_LIBRARIES: int = ...
    TARGET_OBJECT_LIBRARIES_AIX: int = ...
    TARGET_OBJECT_LIBRARIES_SVR4: int = ...
    TARGET_OBJECT_MEMORY: int = ...
    TARGET_OBJECT_MEMORY_MAP: int = ...
    TARGET_OBJECT_OPENVMS_UIB: int = ...
    TARGET_OBJECT_OSDATA: int = ...
    TARGET_OBJECT_RAW_MEMORY: int = ...
    TARGET_OBJECT_SIGNAL_INFO: int = ...
    TARGET_OBJECT_SPU: int = ...
    TARGET_OBJECT_STACK_MEMORY: int = ...
    TARGET_OBJECT_STATIC_TRACE_DATA: int = ...
    TARGET_OBJECT_THREADS: int = ...
    TARGET_OBJECT_TRACEFRAME_INFO: int = ...
    TARGET_OBJECT_UNWIND_TABLE: int = ...
    TARGET_OBJECT_WCOOKIE: int = ...
    arch: Architecture = ...
    docstring: str = ...
    longname: str = ...
    name: str = ...
    shortname: str = ...
    stratum: int = ...
    @classmethod
    def __init__(self) -> None: ...
    def register(self) -> Any: ...
    def unregister(self) -> Any: ...

    def open(self, argstring: str, from_tty: bool) -> None: ...
    def close(self) -> None: ...
    def info(self, thread: InferiorThread) -> str: ...
    def xfer_partial(self, object: int, annex: str, readbuf: bytearray,
                     writebuf: bytearray, offset: int, len: int) -> int: ...
    def extra_thread_info(self) -> str: ...
    def update_thread_list(self) -> None: ...
    def thread_alive(self, ptid: Tuple[int, int, int]) -> bool: ...
    def pid_to_str(self, ptid: Tuple[int, int,int]) -> str: ...
    def fetch_registers(self, thread: InferiorThread,
                        register: Optional[RegisterDescriptor]) -> Optional[RegisterCollectionType]: ...
    def prepare_to_store(self, thread: InferiorThread) -> None: ...
    def store_registers(self, thread: InferiorThread,
                        registers: RegisterCollectionType) -> None: ...
    def has_execution(self, ptid: Tuple[int, int, int]) -> bool: ...

class LinuxKernelTarget(Target):
    kdumpfile: kdumpfile_type = ...

class TargetXferEOF(EOFError): ...

class TargetXferUnavailable(LookupError): ...

class ThreadEvent(Event): ...

class Type:
    alignof: int = ...
    code: int = ...
    name: Optional[str] = ...
    sizeof: int = ...
    tag: Optional[str] = ...
    def array(self, low: int, high: Optional[int] = ...) -> Type: ...
    def const(self) -> Type: ...
    def fields(self) -> List: ...
    def get(self, k: str,
            default: Optional[Field] = ...) -> Optional[Field]: ...
    def has_key(self, k: str) -> bool: ...
    def items(self) -> List: ...
    def iteritems(self) -> Iterator[Tuple[str, Field]]: ...
    def iterkeys(self) -> Iterator[str]: ...
    def itervalues(self) -> Iterator[Field]: ...
    def keys(self) -> List: ...
    def optimized_out(self) -> Value: ...
    def pointer(self) -> Type: ...
    def range(self) -> tuple: ...
    def reference(self) -> Type: ...
    def strip_typedefs(self) -> Type: ...
    def target(self) -> Type: ...
    def template_argument(self, arg: int, block: Optional[Block] = ...) -> Type: ...
    def unqualified(self) -> Type: ...
    def values(self) -> List: ...
    def vector(self, low: int, high: Optional[int] = ...) -> Type: ...
    def volatile(self) -> Type: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, k: Any) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __gt__(self, other: Any) -> bool: ...
    def __iter__(self) -> TypeIterator: ...
    def __le__(self, other: Any) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

class TypeIterator:
    def __iter__(self) -> Any: ...
    def __next__(self) -> Any: ...

class UnwindInfo:
    def add_saved_register(self, reg: IntValue, value: Value) -> None: ...

class Value:
    address: Value = ...
    dynamic_type: Type = ...
    is_lazy: bool = ...
    is_optimized_out: bool = ...
    type: Type = ...
    @classmethod
    def __init__(self, val: Union[Value, Buffer],
                 type: Optional[Type] = ...) -> None: ...
    def cast(self, type: Type) -> Value: ...
    def const_value(self) -> Value: ...
    def dereference(self) -> Value: ...
    def dynamic_cast(self, type: Type) -> Value: ...
    def fetch_lazy(self) -> None: ...
    def format_string(self, **kwargs: Union[bool, int, str]) -> str: ...
    def lazy_string(self, encoding: Optional[str] = ..., length: Optional[int] = ...) -> LazyString: ...
    def reference_value(self) -> Value: ...
    def referenced_value(self) -> Value: ...
    def reinterpret_cast(self, type: Type) -> Value: ...
    def rvalue_reference_value(self) -> Value: ...
    def string(self, encoding: Optional[str] = ..., errors: Optional[str] = ..., length: Optional[int] = ...) -> str: ...
    def __abs__(self) -> Value: ...
    def __add__(self, other: Any) -> Value: ...
    def __and__(self, other: Any) -> Value: ...
    def __bool__(self) -> bool: ...
    def __call__(self, args: Tuple[Any, ...], kwargs: Dict[str, Any]) -> Any: ...
    def __delitem__(self, index: Any) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __float__(self) -> float: ...
    def __ge__(self, other: Any) -> bool: ...
    def __getitem__(self, index: Any) -> Any: ...
    def __gt__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> Value: ...
    def __le__(self, other: Any) -> bool: ...
    def __len__(self) -> int: ...
    def __lshift__(self, other: Any) -> Value: ...
    def __lt__(self, other: Any) -> Value: ...
    def __mod__(self, other: Any) -> Any: ...
    def __mul__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> bool: ...
    def __neg__(self) -> Value: ...
    def __or__(self, other: Any) -> Value: ...
    def __pos__(self) -> Any: ...
    def __pow__(self, other: Any) -> Value: ...
    def __radd__(self, other: Any) -> Any: ...
    def __rand__(self, other: Any) -> Any: ...
    def __rlshift__(self, other: Any) -> Any: ...
    def __rmod__(self, other: Any) -> Any: ...
    def __rmul__(self, other: Any) -> Any: ...
    def __ror__(self, other: Any) -> Any: ...
    def __rpow__(self, other: Any) -> Any: ...
    def __rrshift__(self, other: Any) -> Any: ...
    def __rshift__(self, other: Any) -> Any: ...
    def __rsub__(self, other: Any) -> Any: ...
    def __rtruediv__(self, other: Any) -> Any: ...
    def __rxor__(self, other: Any) -> Any: ...
    def __setitem__(self, index: Any, object: Any) -> Any: ...
    def __sub__(self, other: Any) -> Value: ...
    def __truediv__(self, other: Any) -> Value: ...
    def __xor__(self, other: Any) -> Value: ...

class error(RuntimeError): ...

RecordPosition = Optional[Union[RecordInstruction, RecordGap]]

class Record:
    method: str = ...
    format: str = ...
    replay_position: RecordPosition = ...
    instruction_history: Optional[List[RecordInstruction]] = ...
    function_call_history: Optional[List[RecordFunctionSegment]] = ...
    begin: RecordPosition = ...
    end: RecordPosition = ...
    def goto(self, instruction: Record) -> None: ...

class RecordInstruction:
    number: int = ...
    sal: Symtab_and_line = ...
    pc: int = ...
    data: Buffer = ...
    decoded: str = ...
    size: int = ...
    is_speculative: bool = ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class RecordFunctionSegment:
    number: int = ...
    level: int = ...
    symbol: Symbol = ...
    instructions: List[RecordInstruction] = ...
    up: Optional[RecordFunctionSegment] = ...
    prev: Optional[RecordFunctionSegment] = ...
    next: Optional[RecordFunctionSegment] = ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class RecordGap:
    number: int = ...
    reason_code: int = ...
    reason_string: str = ...

class LazyString:
    address: int = ...
    encoding: str = ...
    length: int = ...
    type: Type = ...
    def value(self) -> str: ...
